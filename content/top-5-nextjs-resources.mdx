---
title: "Top 5 courses and resources to learn Next JS in 2021"
publishedAt: "2020-03-19"
summary: "Get the top 5 resources to learn Next JS in 2021 and take your React skills to the next level"
image: "/static/images/top-5-nextjs-resources/nextjs.png"
---

Recently while building a Digital Asset Management (DAM) system at Rocketium, I was posed with a problem of building a hierarical structure to store files and folders where each folder may have more deeply nested folders containing files. Now, while this problem is simple to visualise (with a tree structure), it reveals some hidden challenges when there is deep nesting within folders and you need to perform operations like deleting a folder, where you will eventually have to set properties for all the children of that folder as well.
At Rocketium, we use MongoDB as our primary database for storing file and folder information, and I had to design a fast and functional schema to support CRUD operations at scale. I started building it after locking in on one approach, but hit a roadblock real soon, only to find the beauty of problem solving in the second approach.

## Let’s understand the problem

Imagine that you need to save multiple folders within a folder and those folders can have nested folders within them. Folders may or may not contain a file within them. So if I map out a tree as an example to illustrate the structure it would look something like this —
File and folder structure
File and folder structure
Where we start from the Root which has folders prefixed with F and files prefixed with A (for assets). For simplicity, we’ll consider that folder and file names are unique identifiers. Each node will have some properties associated with it, such as its name, and its deletion status. Hence F1 will have data model which resembles —

```
{
"\_id": "F1",
"name": "F1",
"isDeleted": false
}
```

Now there are multiple approaches to traverse this tree, to update its properties, when it is stored as a collection of documents inside MongoDB. I will be discussing two of them - one naive and one sophisticated.

## The naive approach: Parent Referencing 🥚

The first approach that came to my mind was to store the \_id of the parent in the child node. This means each child can identify its parent. For example -
F1’s parent will be root
F4’s parent will be F2.
Similarly we can also assign the parent node for assets (or files) as well
A1’s parent is root
A2’s parent would be F1.

And hence the new data model of F1 will look like

```
{
"\_id": "F1",
"name": "F1",
"isDeleted": false,
"parentId": "root"
}
```

This approach is called as Parent Referencing, where to find the children nodes of any parent is as simple as querying the collection with the parentId field. For example, to find all the children of F1 we can simply query the collection with parentId: F1.

```
db.find({ parentId: "F1" });

/_ Returns
[
{
"_id": "A2",
"name": "A2",
"isDeleted": false,
"parentId": "F1"
},
{
"_id": "F3",
"name": "F3",
"isDeleted": false,
"parentId": "F1"
}
]
_/
```

This approach was all fine and good for shallow nesting, and I was able to implement insert, update, and read operations with ease. But then I hit a roadblock when I had to implement the delete operation, when I realised that I need to delete all the children of a folder as well. And this is where this approach will give me a hard time. 😵‍💫
Let me tell you why.

## The problem with Parent Referencing 🍳

Let’s say we want to delete F1 and all its children. We can simply query `{ parentId: "F1" }` to get all the children and mark isDeleted: true for each of them in a single DB query.
But what if we want to delete F2? 😳
Then we need to first mark F4 and F5 for deletion, but also then make another query to find children of F5 to mark them for deletion as well. This means we need to make multiple queries to the database to delete a single folder. And this gets worse with the depth of nesting. We cannot stop till we reach the leaf nodes (assets or folders without any children) 😰

If I give a rough TS implementation of this approach, it would look something like this —

```
const deleteFolderWithId = (folderId: string) => {
// First find the folder and mark it for deletion
const folder = db.findOneAndUpdate({ \_id: folderId }, { isDeleted: true });

    // Then recursively delete all children
    const children = db.find({ parentId: folderId });

    children.forEach(child => {
        if (child.type === 'folder') {
            deleteFolderWithId(child._id); // <-- This is a recursive call
        } else {
            db.findOneAndUpdate({ _id: child._id }, { isDeleted: true });
        }
    });

}
```

When I hit this use case I realised that this approach is not going to work for us. We need to find a better way to store the data, considering the scale at which we operate.

## The sophisticated approach: Materialized Paths 🎩

Upon some reading and researching on the internet, I stumbled upon a way to store this tree structure as a flat collection of documents. The idea is to store the path from the root to a node, in a single field, and then use that field to query the database to find all the children of a node. And everytime we add a new node we calculate its path from the root and store it in the database.
This means that the calculated path of —
F1 -> root
F3 -> root, F1
F5 -> root, F2
A4 -> root, F2, F5
And the data model for A4 will look like —

```
{
"\_id": "A4",
"name": "A4",
"isDeleted": false,
"path": "root, F2, F5"
}
```

Calculated materialised paths for each node
Calculated materialised paths for each node
So now if I wish to query all the direct children of F2, I can simply query the database with path: "root, F2" and it will return all the children of F2 in a single query.
`db.find({ path: "root, F2" });`
This approach is known as Materialized Paths because we are storing the path of a node in a single field. It seemed a bit peculiar to me at the start, but proved to be an elegant approach to store tree-like structures in NoSQL databases like MongoDB.

## Materialized Paths in action 🪄

Let’s try to tackle the same problem of deleting F2, with all its deeply nested children. We can now do it in a single query, by simply finding all the documents whose path starts with root, F2 and mark them for deletion ✅

And this time since there are no recursive function calls, hence lesser load on the system, and faster execution 😎

```
const deleteFolderWithId = (folderId: string) => {
// Finds the folder and marks it for deletion
const folder = db.findOneAndUpdate({ \_id: folderId }, { isDeleted: true });

    // Finds all children and marks them for deletion
    const childrenFolderPath = `${folder.path}, ${folderId}`;

    // Delete all children
    db.updateMany(
        /* This regex matches all documents whose path
        * starts with the `childrenFolderPath` 👇
        */
        { path: { $regex: `^${childrenFolderPath}` } },
        { isDeleted: true }
    );

}
```

## Problems with Materialized Paths 🤓

While this approach is fast and efficient for most operations, certain operations like Moving a folder from one folder to another becomes a pain.
For example if one day we decide to move F5 from F2 to F1, then we will have to update the path for all its nested children to point to the new parent.
Plus there will be a lot of checks to ensure the consistency of the data manually. For example, if we move F5 to F1, we will have to ensure that F1 is not a child of F5 or any of its children. It could be a mental overload to implement this. But considering the benefits, I think it is worth it.
Whereas, with the Parent Referencing approach, we can simply update the parentId field of F5 to point to F1 and we are done 😬

```js
const moveFolder = (currentFolderId: string, toFolderId: string) => {
const currentFolder = db.findOne({ \_id: currentFolderId });

    db.updateOne(
        { _id: currentFolderId },
        { parentId: toFolderId }
    );

}
```

## What should you use? 🤔

I feel both the approaches have their pros and cons, but what you should use depends on your use case. For mine, deleteing (and bulk deleting) files and folders are more common operations than moving folders around, so I decided to go with the Materialized Paths approach. Plus we are expected to have deeply nested folders and where calculating the breadcrumbs for each folder might be slow if we had to do it recursively for large number of documents.
I hope this article helped you understand the approaches to store and manipulated nested structures in MongoDB. If you liked this post or if you have any questions or suggestions, feel free to reach out to me on Twitter @viveknigam\_ 😄
Until then, happy hacking 👋

```jsx
  getContentPath: (filePath = '') => {
    const rootPath = process.cwd();
    const contentFolder = path.join(path.join(rootPath, 'content', filePath));
    return contentFolder;
  },
```
